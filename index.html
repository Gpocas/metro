<!DOCTYPE html>
<html lang="pt-BR">

<head>
  <meta charset="UTF-8" />
  <meta meta name="viewport" content="maximum-scale=1, user-scalable=no">
  <title>Metro Game</title>
  <link href="./output.css" rel="stylesheet">
  <link rel="icon" type="image/x-icon" href="./favicon.ico">
  <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
</head>

<body>
  <div id="app" class="bg-zinc-900 min-h-screen">

      <nav class="text-white text-center font-bold sm:text-7xl sm:p-4 lg:text-4xl lg:p-2 font-mono">
        {{name}}
      </nav>
      <hr />
  
      <div v-if="win" class="flex flex-col items-center md:pt-8">
        <div class="text-green-600 text-center font-bold text-3xl p-2 font-mono"> Parabens Você acertou :)</div>
        <button class="text-white bg-blue-500 font-bold rounded-md p-2 px-4" @click="newGame()">New Game</button>
  
      </div>
  
      <div v-if="win === false" class="flex flex-col items-center">
        <div class="text-red-600 text-center font-bold text-3xl p-2 font-mono"> A palavra era {{word}}, quem sabe na
          proxima :(</div>
        <button class="text-white bg-blue-500 font-bold rounded-md p-2 px-4" @click="newGame()">New Game</button>
      </div>
  
      <div id="gameboard" class="sm:py-20 sm:pb-28  lg:py-5 px-10 grid gap-y-1 items-center w-100 justify-center">
        <div v-for="(row, index1) in gameBoard" class="flex gap-1 w-fit">
          <div v-for="(cell, index2) in row"
            class="sm:w-28 sm:h-28 sm:text-3xl lg:w-14 lg:h-14 lg:text-xl grid place-items-center p-0 m-0 font-bold  rounded-sm text-black border-2 border-gray-300 dark:bg-zinc-800 dark:text-white">
            {{ cell || ' ' }}
          </div>
        </div>
  
        <div class="grid place-items-center h-8 font-bold dark:text-white"></div>
      </div>
  
      <div class="flex flex-col items-center  w-100 pb-5">
        <div class="flex gap-1 my-0.5 w-fit">
          <button v-for="l in line1" @click="key(l)"
            class=" sm:h-28 sm:w-20 lg:w-12 sm:text-3xl lg:h-12 lg:text-base bg-gray-200 hover:bg-gray-300 dark:bg-zinc-400 dark:text-white dark:hover:bg-zinc-500  300 grid items-center rounded font-semibold cursor-pointer">
            {{l}}
          </button>
  
        </div>
        <div class="flex gap-1 my-0.5 w-fit">
          <button v-for="l in line2" @click="key(l)"
            class="sm:h-28 sm:w-20 sm:text-3xl lg:w-12 lg:h-12 lg:text-base bg-gray-200 hover:bg-gray-300 dark:bg-zinc-400 dark:text-white dark:hover:bg-zinc-500  300 grid items-center rounded font-semibold cursor-pointer">
            {{l}}
          </button>
  
  
        </div>
        <div class="flex gap-1 my-0.5 w-fit">
          <button @click="key('Enter')"
            class=" sm:h-28 sm:p-12 sm:text-3xl lg:p-4 lg:h-12 lg:text-base bg-gray-200 hover:bg-gray-300 dark:bg-zinc-400 dark:text-white dark:hover:bg-zinc-500 flex items-center rounded font-semibold cursor-pointer">
            ENTER
          </button>
  
          <button v-for="l in line3" @click="key(l)"
            class="sm:w-20 sm:h-28 sm:text-3xl lg:w-12 lg:h-12 lg:text-base bg-gray-200 hover:bg-gray-300 dark:bg-zinc-400 dark:text-white dark:hover:bg-zinc-500 300 grid items-center rounded font-semibold cursor-pointer">
            {{l}}
          </button>
  
          <button @click="key('Remove')"
            class=" sm:p-10 sm:px-16 sm:h-28 lg:p-4 lg:px-7 lg:h-12 bg-gray-200 hover:bg-gray-300 dark:bg-zinc-400 dark:text-white dark:hover:bg-zinc-500  flex items-center rounded font-semibold cursor-pointer">
            <svg xmlns="http://www.w3.org/2000/svg"  fill="currentColor" class="sm:w-8 sm:h-8 lg:w-4 lg:h-4"
              viewBox="0 0 16 16">
              <path
                d="M2 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2zm3.354 4.646L8 7.293l2.646-2.647a.5.5 0 0 1 .708.708L8.707 8l2.647 2.646a.5.5 0 0 1-.708.708L8 8.707l-2.646 2.647a.5.5 0 0 1-.708-.708L7.293 8 4.646 5.354a.5.5 0 1 1 .708-.708" />
            </svg>
          </button>
        </div>
      </div>

    </div>

  <script src="words.js"></script>
  <script>
    const app = Vue.createApp({
      data() {

        const removeAccents = str =>
          str.normalize('NFD').replace(/[\u0300-\u036f]/g, '');

        newWord = removeAccents(words[Math.floor(Math.random() * words.length)]);

        return {


          name: "Metro",
          word: newWord.toUpperCase(),
          win: null,
          currentLineIndex: 0,
          line1: "QWERTYUIOP",
          line2: "ASDFGHJKL",
          line3: "ZXCVBNM",
          gameBoard: [
            ['', '', '', '', ''],
            ['', '', '', '', ''],
            ['', '', '', '', ''],
            ['', '', '', '', ''],
            ['', '', '', '', ''],
            ['', '', '', '', ''],

          ],
        };
      },

      methods: {

        newGame() {
          location.reload();
        },

        sortWord(max, min) {
          let valor = Math.random() * (max - min) + min
          return Math.floor(valor)
        },



        key(l) {
          if (l === 'Enter') {
            const currentLine = this.gameBoard[this.currentLineIndex]
            const currentArray = [...currentLine]

            if (currentArray.includes("")) {
              return
            }
            else {

              if (this.currentLineIndex === 5) {

                const buttons = document.getElementsByTagName("button");
                for (const button of buttons) {
                  button.disabled = true;
                }

                this.win = false



              }

              if (currentArray.join('') === this.word) {

                divs = document.querySelector('#gameboard').childNodes[this.currentLineIndex + 1].querySelectorAll('div')

                for (const [index, d] of divs.entries()) {
                  d.classList.remove('dark:bg-zinc-800')
                  d.classList.add('bg-green-700')

                }

                this.win = true

              }
              else {

                info = this.checkWord(currentArray.join(''))

                divs = document.querySelector('#gameboard').childNodes[this.currentLineIndex + 1].querySelectorAll('div')

                for (const [index, d] of divs.entries()) {

                  if (info.verdes.includes(index + 1)) {
                    d.classList.remove('dark:bg-zinc-800')
                    d.classList.add('bg-green-700')
                  }

                  else if (info.amarelas.includes(index + 1)) {
                    d.classList.remove('dark:bg-zinc-800')
                    d.classList.add('bg-yellow-500')
                  }

                  else {
                    d.classList.remove('dark:bg-zinc-800')
                    d.classList.add('dark:bg-zinc-600')

                  }

                }


                this.moveToNextLine();
              }
            }


          }
          else if (l === 'Remove') {
            this.removeLastFilledElement();

          }
          else {

            // Obtém a linha atual com base no índice atual
            const currentLine = this.gameBoard[this.currentLineIndex];
            // Encontra o primeiro espaço vazio na linha atual e preenche com a letra
            const emptyIndex = currentLine.indexOf('');
            if (emptyIndex !== -1) {
              currentLine[emptyIndex] = l;
            }


          }

        },
        moveToNextLine() {
          // Incrementa o índice da linha atual se não for a última linha
          if (this.currentLineIndex < this.gameBoard.length - 1) {
            this.currentLineIndex++;
          }
        },

        removeLastFilledElement() {
          // Obtém a linha atual com base no índice atual
          const currentLine = this.gameBoard[this.currentLineIndex];
          // Encontra o índice do último elemento preenchido na linha atual
          let lastFilledIndex = -1;
          for (let i = currentLine.length - 1; i >= 0; i--) {
            if (currentLine[i] !== '') {
              lastFilledIndex = i;
              break;
            }
          }
          // Se houver um último elemento preenchido, limpa esse índice
          if (lastFilledIndex !== -1) {
            currentLine[lastFilledIndex] = '';
          }
        },


        checkWord(currentWord) {
          let verdes = [];
          let amarelas = [];

          // Inicializa o contadorOriginal com 0 para cada letra da palavra original
          const contadorOriginal = {};
          // Inicializa o contadorAtual com 0 para cada letra da palavra atual
          const contadorAtual = {};

          // Preenche os contadores para cada palavra
          for (const letra of this.word) {
            contadorOriginal[letra] = (contadorOriginal[letra] || 0) + 1;
          }

          for (const letra of currentWord) {
            contadorAtual[letra] = (contadorAtual[letra] || 0) + 1;
          }

          // Verifica as letras verdes
          for (let i = 0; i < currentWord.length; i++) {
            const letraAtual = currentWord[i];
            const letraOriginal = this.word[i];

            if (letraAtual === letraOriginal) {
              verdes.push(i + 1);
              // Decrementa o contadorAtual para evitar que a letra seja contada novamente
              contadorAtual[letraAtual]--;
              // Decrementa o contadorOriginal para evitar que a letra seja contada novamente
              contadorOriginal[letraOriginal]--;
            }
          }

          // Verifica as letras amarelas
          for (let i = 0; i < currentWord.length; i++) {
            const letraAtual = currentWord[i];
            const letraOriginal = this.word[i];

            if (letraAtual !== letraOriginal && contadorOriginal[letraAtual] > 0) {
              amarelas.push(i + 1);
              // Decrementa o contadorOriginal para evitar que a letra seja contada novamente como amarela
              contadorOriginal[letraAtual]--;
            }
          }

          const info = {
            'verdes': verdes,
            'amarelas': amarelas
          };

          return info;
        }

      }

    });

    app.mount("#app");
  </script>
</body>

</html>